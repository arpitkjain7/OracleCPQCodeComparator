/*****************************************************************
Function Name : Recc_Item_Select_Parts
Name : K Acharya
Description : Rule to Recommend Item and provide pricing(Perpetual/Subscription)
Date : 17/12/2018
*****************************************************************/
/*****************************************************************
Function Name : Recc_Item_Select_Parts
Name : Kavita Lolla
Change Description : SYMINT-4426 - Reconfig wipes out the previously configured parts.
Date : 27/01/2020
*****************************************************************/

result = "";

currency="USD";
exch="1";
resultcurr=bmql("SELECT currency_t from commerce.transaction");
StartDate="";
EndDate="";
StartDate2="";
EndDate2="";
for rescurr in resultcurr{
currency=get(rescurr,"currency_t");
}

resultexchangerate=bmql("SELECT USD_To_Local_Curr from Exchange_Rate_Data WHERE Currency_Code=$currency");
for exchange in resultexchangerate{
exch=get(exchange, "USD_To_Local_Curr");
}
transTypeDict=dict("string");
comment="";

delim = "~";
delimiSep= "|^|";
partString="";
partNoDict=dict("string");
cost = "";
Calc_price="";
identifiervar=0;
//SYMINT-4426 - Begin - Holds the max value of identifier.
maxidentifier=0;
//SYMINT-4426 - End
AccountNums=accountNo_avg+"~"+billToAccountId_avg+"~"+endCustomerAccountId_avg +"~" + endCustomerParentId + "~" ;

jsonObj = json();

if(parentChildString_avg <> "" AND parentChildString_avg<>" "){
jsonObj = json(parentChildString_avg);
}
//This dictionary stores counter and type
partTypeDict=dict("string");
//This dictionary stores part no and description
partNoDescDict=dict("string");
PartQuantityDict=dict("string");
PartLicenseDict=dict("string");
CommentDict=dict("string");
PartStartDateDict=dict("date");
PartEndDateDict=dict("date");
SupportTypeDict=dict("string");
SupportPartDict=dict("string");
PriceCalcDict=dict("string");
size=range(partSelectionArrayControl_avg);
partNumQuantityDict=dict("string");
for counter in size
{  Key= "Item" + String(counter);
  EffectiveStartDate=datetostr(lineEffectiveStartDate_avg,"yyyy-MM-dd HH:mm:ss", "America/Chicago");
  LicenseType=jsonpathgetsingle(jsonObj,"$."+string(counter)+".child.selectLicenseType","string","");
  StartDate=jsonpathgetsingle(jsonObj,"$."+string(counter)+".child.startDate","string","");
   if(StartDate<>"" ){
                StartDate1=strtojavadate(StartDate,"MM/dd/yyyy HH:mm:ss", "America/Chicago");
                StartDate2=datetostr(StartDate1, "yyyy-MM-dd HH:mm:ss", "America/Chicago");
                }
                
  EndDate=jsonpathgetsingle(jsonObj,"$."+string(counter)+".child.endDate","string","");
  if(EndDate<>"" ){
                EndDate1=strtojavadate(EndDate,"MM/dd/yyyy HH:mm:ss", "America/Chicago");
                EndDate2=datetostr(EndDate1, "yyyy-MM-dd HH:mm:ss", "America/Chicago");
                }
  supportType=jsonpathgetsingle(jsonObj,"$."+string(counter)+".child.supportType","string","");
  supportPart=jsonpathgetsingle(jsonObj,"$."+string(counter)+".child.supportPartsPicklist","string","");
  CPN=jsonpathgetsingle(jsonObj,"$."+string(counter)+".child.CPN","string","");
  transType=jsonpathgetsingle(jsonObj,"$."+string(counter)+".child.transactionType","string","");
  comment=jsonpathgetsingle(jsonObj,"$."+string(counter));
  put(partNoDict, Key, PartNumber_avg[counter]);
  put(partTypeDict, Key, "Model");
  put(partNoDescDict,Key,selectProductByName_avg[counter]);
  put(PartQuantityDict, Key, string(quantity_avg[counter]));
  if(isnull(StartDate))
  {
   StartDate=getstrdate();
  }
  
  if(isnull(EndDate))
  {
   EndDate=getstrdate();
  }
  
  
  AccountNums=AccountNums + endCustomerGrandParentId_avg + "~" + CPN + "~" + EffectiveStartDate + "~" + EffectiveStartDate + "~" + routeToMarket_avg+ "~" + billToParentId_avg +"~" + billToGrandParentId_avg + "~" + quoteType_avg;
  
                put(PartLicenseDict, Key, licenseType);
                if(StartDate<>"" ){
                put(PartStartDateDict, Key, strtojavadate(StartDate,"MM/dd/yyyy HH:mm:ss", "America/Chicago"));
      
                }
                if(EndDate<>"" ){
                put(PartEndDateDict, Key, strtojavadate(EndDate,"MM/dd/yyyy HH:mm:ss", "America/Chicago"));
                }
                put(CommentDict, Key, comment);
                put(SupportTypeDict,Key,supportType);
                put(SupportPartDict, Key, supportPart);
                put(transTypeDict,Key,transType);
}

Partvalues=values(partNoDict);
for each in Partvalues{
 if(isnull(each) == false){
 partString=partString+ "~" + each;
    }
}  

//Call Pricing util to fetch prices
partPriceDict=dict("string");

partPriceDict=util.configpricing_brcm(partString,AccountNums,partNoDict);
partDescDict=dict("string");

partArray=split(partString,"~");

contractdetials=string[2];
partKeys=Keys(partNoDict);
//SYMINT-4426 - Begin - Compute the max value of identifier assigned.
for each in partKeys
{
  pcstring = get(CommentDict,each);
  pcstringjson = json(pcstring);
  currentIdentifierS = jsonget(pcstringjson,"Identifier");
  if(currentIdentifierS <> "" AND currentIdentifierS <> " " AND NOT isnull(currentIdentifierS))
  {
   currentIdentifier = atoi(currentIdentifierS);
   if(maxidentifier < currentIdentifier)
   {
    maxidentifier = currentIdentifier;
   }
  }
}

//SYMINT-4426 - End
for each in partKeys{
identifiervar=identifiervar+1;
if(get(PartLicenseDict,each)=="Perpetual" or get(PartLicenseDict, each)=="UMF"){
if(each <> ""){
  itemprice="";
  if(find(get(partPriceDict,each),"~")<>-1)
  {
   contractdetials= split(get(partPriceDict,each), "~");
   
  }
  else
  {
   contractdetials[0]=get(partPriceDict,each);
  }
  if(get(transTypeDict,each)<>"Renew"){
  //SYMINT-4426 - Begin - Return assigned previous identifier stored in parent child string / increment to assign the new value and store the same in parent child string.
  pcstring = get(CommentDict,each);
  pcstringjson = json(pcstring);
  identifierStored = jsonget(pcstringjson,"Identifier");
  //print identifierStored;
  //print string(isnull(identifierStored));
  //print identifiervar;
  if(identifierStored <> "" AND identifierStored <> " " AND NOT isnull(identifierStored))
  {
   identifiervar = atoi(identifierStored);
  }
  else
  {
   identifiervar = maxidentifier + 2;
   maxidentifier = identifiervar;
              jsonput(pcstringjson,"Identifier",string(identifiervar));
              put(CommentDict,each,jsontostr(pcstringjson));
        } 
        //SYMINT-4426 - End
  result=result+ get(partNoDict, each) + "~" +get(PartQuantityDict, each)+ "~" + get(CommentDict, each) + "~"+ String(atof(contractdetials[0])*atof(exch)) + "~" + string(identifiervar) + "|^|";
  }
       
       }
             }
             elif(get(PartLicenseDict,each)=="Subscription"){
             partNo=get(partNoDict, each);
             
             if(find(get(partPriceDict,each),"~")<>-1)
   {
   contractdetials= split(get(partPriceDict,each), "~");
   
   }
   else
   {
   contractdetials[0]=get(partPriceDict,each);
   }
             
             partPrice=contractdetials[0];
             
             PartStartDate=get(PartStartDateDict, each);
             SupportType=get(SupportTypeDict, each);
             SupportPart=get(SupportPartDict, each);
             Comment=get(CommentDict,each);
           
             PartEndDate=get(PartEndDateDict, each);
             if((ISNULL(PartStartDate)==false) AND (ISNULL(PartEndDate )==false) ){
             days=getdiffindays(partEndDate, partStartDate) + 1;
       Calc_price=util.subscriptionPriceCalculation_brcm(partNo,partPrice,PartStartDate,PartEndDate,currency);
             
             PriceCalcDict=util.maintenanceSupportCalculation_brcm(PartNo, SupportType, partPrice, PartStartDate, PartEndDate);
             
             }
             //SYMINT-4426 - Begin - Return assigned previous identifier stored in parent child string / increment to assign the new value and store the same in parent child string.
    pcstring = get(CommentDict,each);
    pcstringjson = json(pcstring);
    identifierStored = jsonget(pcstringjson,"Identifier");
    //print identifierStored;
    //print identifiervar;
    if(identifierStored <> "" AND identifierStored <> " " AND NOT isnull(identifierStored))
    {
     identifiervar = atoi(identifierStored);
    }
    else
    {
     identifiervar = maxidentifier + 2;
     maxidentifier = identifiervar;
                jsonput(pcstringjson,"Identifier",string(identifiervar));
                put(CommentDict,each,jsontostr(pcstringjson));
          } 
        //SYMINT-4426 - End
             result=result+ get(partNoDict, each) + "~" +get(PartQuantityDict, each)+ "~" + get(CommentDict, each) + "~"+ String(atof(Calc_price)*atof(exch)*365/days) + "~" + string(identifiervar) + "|^|";
       
             identifiervar=identifiervar+1;
             if(get(SupportPartDict,each)<>""){
               //SYMINT-4426 - Begin - Get the parent identifier and add 1 to get the support part identifier since no separate Parent Child String for support parts.
     pcstring = get(CommentDict,each);
     pcstringjson = json(pcstring);
     identifierStored = jsonget(pcstringjson,"Identifier");
     //print identifierStored;
     //print identifiervar;
     if(identifierStored <> "" AND identifierStored <> " " AND NOT isnull(identifierStored))
     {
      identifiervar = atoi(identifierStored);
     }
     else
     {
      identifiervar = maxidentifier + 2;
      maxidentifier = identifiervar;
                 jsonput(pcstringJson,"Identifier",string(identifiervar));
                 put(CommentDict,each,jsontostr(pcstringjson));
           }  
           identifiervar = identifiervar + 1;
           maxidentifier = identifiervar;
          //SYMINT-4426 - End
              result=result+ get(SupportPartDict,each) + "~" +get(PartQuantityDict, each)+ "~" + get(CommentDict, each) + "~"+  String(atof(get(PriceCalcDict, "Support"))*atof(exch)*365/days) + "~" + string(identifiervar) + "|^|";
             }
             
             }
             
                        }
                        
//Maintenance and support Calculator
for each in partKeys{
 identifiervar=identifiervar+1;
if(get(PartLicenseDict,each)=="Perpetual" or get(PartLicenseDict, each)=="UMF"){
if(each <> ""){
 
  
             PartNo=get(partNoDict, each);
             
             if(find(get(partPriceDict,each),"~")<>-1)
   {
   contractdetials= split(get(partPriceDict,each), "~");
   
   }
   else
   {
   contractdetials[0]=get(partPriceDict,each);
   }
             
             partPrice=contractdetials[0];
             PartStartDate=get(PartStartDateDict, each);
             PartEndDate=get(PartEndDateDict, each);
             SupportType=get(SupportTypeDict, each);
             SupportPart=get(SupportPartDict, each);
             Comment=get(CommentDict,each);
             put(PriceCalcDict,"Support","");
             days=getdiffindays(partEndDate, partStartDate) + 1;
             if((ISNULL(PartStartDate)==false) AND (ISNULL(PartEndDate)==false) ){
             PriceCalcDict=util.maintenanceSupportCalculation_brcm(PartNo, SupportType, partPrice, PartStartDate, PartEndDate);
             
             }

             if(get(SupportPartDict,each)<>""){
             //SYMINT-4426 - Begin - Get the parent identifier and add 1 to get the support part identifier since no separate Parent Child String for support parts.
    pcstring = get(CommentDict,each);
    pcstringjson = json(pcstring);
    identifierStored = jsonget(pcstringjson,"Identifier");
    //print identifierStored;
    //print identifiervar;
    if(identifierStored <> "" AND identifierStored <> " " AND NOT isnull(identifierStored))
    {
     identifiervar = atoi(identifierStored);
    }
    else
    {
     identifiervar = maxidentifier + 2;
     maxidentifier = identifiervar;
                jsonput(pcstringJson,"Identifier",string(identifiervar));
              put(CommentDict,each,jsontostr(pcstringjson));
          } 
          identifiervar = identifiervar + 1;
          maxidentifier = identifiervar;
         //SYMINT-4426 - End
               result=result+ get(SupportPartDict,each) + "~" +get(PartQuantityDict, each)+ "~" + get(CommentDict, each) + "~"+ String(atof(get(PriceCalcDict, "Support"))*atof(exch)*365/days)+ "~" + string(identifiervar) + "|^|";
             }
             
       
       }
             }
                        }                        
                      

          
return result;